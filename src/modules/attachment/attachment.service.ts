import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Attachment } from './schema/attachment.schema';
import { ConfigService } from '@nestjs/config';
import * as path from 'path';
import { Multer } from 'multer';

@Injectable()
export class AttachmentService {
  private readonly logger = new Logger(AttachmentService.name);
  private readonly baseUrl: string;

  constructor(
    @InjectModel(Attachment.name)
    private readonly attachmentModel: Model<Attachment>,
    private readonly configService: ConfigService, // Inject ConfigService
  ) {
    // Construct base URL for serving files. Use API_BASE_URL if available, otherwise construct from APP_HOST/APP_PORT
    const apiBaseUrl = this.configService.get<string>('API_BASE_URL') || 
                      process.env.API_BASE_URL ||
                      (() => {
                        // Fallback: construct from APP_HOST and APP_PORT
                        const appHost = this.configService.get<string>('APP_HOST', 'http://localhost');
                        const appPort = this.configService.get<number>('APP_PORT', 3000);
                        const isProduction = this.configService.get<string>('NODE_ENV') === 'production';
                        
                        // In production, use https://mazadclick-server.onrender.com if APP_HOST is not explicitly set
                        // if (isProduction && (appHost.includes('localhost') || !appHost.startsWith('https'))) {
                        //   return 'http://localhost:3000';
                        // }
                        if (isProduction && (appHost.includes('localhost') || !appHost.startsWith('https'))) {
                          return process.env.API_BASE_URL || 'https://mazadclick-server.onrender.com';
                        }
                        
                        const hostPart = appPort && !appHost.includes(':') ? appHost.replace(/\/$/, '') : appHost.replace(/\/$/, '');
                        return appPort && !hostPart.includes(':') ? `${hostPart}:${appPort}` : hostPart;
                      })();
    
    this.baseUrl = `${apiBaseUrl.replace(/\/$/, '')}/static`;
    this.logger.log(`Base URL for attachments: ${this.baseUrl}`);
  }

  async upload(
    file: Express.Multer.File,
    as: string, // AttachmentAs (e.g., 'BID_THUMB', 'CATEGORY_IMAGE')
    user: Types.ObjectId | string | null, // Allow null for guest users
  ): Promise<Attachment> {
    if (!file) {
      this.logger.warn('Upload attempt with no file provided.');
      throw new Error('File is required for upload.');
    }

    this.logger.log(`Processing upload for file: ${file.originalname}, path: ${file.path}`);
    this.logger.log(`File details: size=${file.size}, mimetype=${file.mimetype}, fieldname=${file.fieldname}`);

    // Validate file
    if (file.size === 0) {
      this.logger.error('File is empty (0 bytes)');
      throw new Error('File cannot be empty');
    }

    if (!file.filename) {
      this.logger.error('File has no filename');
      throw new Error('File must have a filename');
    }

    // Construct the public URL for the file
    // file.filename is generated by our Multer config (e.g., originalname-random.ext)
    const publicUrl = `/static/${file.filename}`;
    // Use the baseUrl from constructor, which handles production URLs correctly
    const apiBase = this.baseUrl.replace('/static', '');
    const fullUrl = `${apiBase}${publicUrl}`;


    const attachmentData = {
      fieldname: file.fieldname,
      originalname: file.originalname,
      encoding: file.encoding,
      mimetype: file.mimetype,
      size: file.size,
      destination: file.destination, // Provided by Multer diskStorage
      filename: file.filename,     // Provided by Multer diskStorage
      path: file.path || (file.destination && file.filename ? path.join(file.destination, file.filename) : undefined),
      url: publicUrl,            // Publicly accessible URL
      fullUrl: fullUrl,          // Full URL with domain
      as,
      createdAt: new Date(),
      // Only set user if provided (null for guest users)
      user: user ? (typeof user === 'string' ? new (require('mongoose').Types.ObjectId)(user) : user) : undefined,
    };

    this.logger.debug(`Saving attachment metadata: ${JSON.stringify(attachmentData)}`);
    
    let attachment;
    try {
      attachment = await this.attachmentModel.create(attachmentData);
      this.logger.log(`Attachment saved to database with ID: ${attachment._id}`);
    } catch (dbError) {
      this.logger.error(`Failed to save attachment to database: ${dbError.message}`);
      throw new Error(`Database error: ${dbError.message}`);
    }

    // Add full URL to the response
    const attachmentWithFullUrl = attachment.toObject() as any;
    attachmentWithFullUrl.fullUrl = `${this.baseUrl.replace('/static', '')}${publicUrl}`;
    
    // Ensure all required fields are present
    if (!attachmentWithFullUrl.size && attachment.size) {
      attachmentWithFullUrl.size = attachment.size;
    }

    this.logger.log(`Attachment created with ID: ${attachment._id} and URL: ${attachment.url}`);
    this.logger.log(`Full URL: ${attachmentWithFullUrl.fullUrl}`);
    this.logger.log(`Attachment size: ${attachmentWithFullUrl.size} bytes`);
    this.logger.log(`Attachment full response:`, JSON.stringify(attachmentWithFullUrl, null, 2));
    
    return attachmentWithFullUrl;
  }

  async findById(id: string): Promise<Attachment | null> {
    this.logger.log(`Finding attachment by ID: ${id}`);
    const attachment = await this.attachmentModel.findById(id).exec();
    if (attachment) {
      const attachmentWithFullUrl = attachment.toObject() as any;
      attachmentWithFullUrl.fullUrl = `${this.baseUrl.replace('/static', '')}${attachment.url}`;
      return attachmentWithFullUrl;
    }
    return attachment;
  }

  async findByUserAndType(userId: string, as: string): Promise<Attachment | null> {
    this.logger.log(`Finding attachment by user: ${userId} and type: ${as}`);
    const attachment = await this.attachmentModel.findOne({ 
      user: new Types.ObjectId(userId), 
      as 
    }).exec();
    if (attachment) {
      const attachmentWithFullUrl = attachment.toObject() as any;
      attachmentWithFullUrl.fullUrl = `${this.baseUrl.replace('/static', '')}${attachment.url}`;
      return attachmentWithFullUrl;
    }
    return attachment;
  }

  async getUserAvatar(userId: string): Promise<Attachment | null> {
    this.logger.log(`Finding avatar for user: ${userId}`);
    return this.findByUserAndType(userId, 'AVATAR');
  }

  async updateAttachment(
    attachmentId: string,
    file: Express.Multer.File,
    userId: string
  ): Promise<Attachment> {
    this.logger.log(`Updating attachment: ${attachmentId} for user: ${userId}`);
    
    // Construct the public URL for the file
    const publicUrl = `/static/${file.filename}`;

    const updateData = {
      fieldname: file.fieldname,
      originalname: file.originalname,
      encoding: file.encoding,
      mimetype: file.mimetype,
      size: file.size,
      destination: file.destination,
      filename: file.filename,
      path: file.path || (file.destination && file.filename ? path.join(file.destination, file.filename) : undefined),
      url: publicUrl,
      updatedAt: new Date(),
    };

    this.logger.debug(`Updating attachment metadata: ${JSON.stringify(updateData)}`);
    const updatedAttachment = await this.attachmentModel.findByIdAndUpdate(
      attachmentId,
      updateData,
      { new: true }
    );

    // Add full URL to the response
    const attachmentWithFullUrl = updatedAttachment.toObject() as any;
    attachmentWithFullUrl.fullUrl = `${this.baseUrl.replace('/static', '')}${publicUrl}`;

    this.logger.log(`Attachment updated with ID: ${updatedAttachment._id} and URL: ${updatedAttachment.url}`);
    this.logger.log(`Full URL: ${attachmentWithFullUrl.fullUrl}`);
    return attachmentWithFullUrl;
  }

  // Optional: Add a method to delete the file from disk and DB if needed
  async delete(attachmentId: string): Promise<void> {
    const attachment = await this.attachmentModel.findByIdAndDelete(attachmentId);
    if (attachment && attachment.path) {
      try {
        // TODO: fs.unlinkSync(attachment.path); // Be careful with this in production
        this.logger.log(`File ${attachment.path} metadata deleted. Physical file deletion can be added here.`);
      } catch (err) {
        this.logger.error(`Error deleting file ${attachment.path}: ${err.message}`);
      }
    }
  }
}
